#!/bin/bash
# bash is needed to be able to use arrays, as the POSIX standard does not have arrays (bash implements POSIX Shell standard and extends it)
SERVER_OUTPUT_PATH=/tmp/quarkus-test/server/output
CLIENT_OUTPUT_PATH=/tmp/quarkus-test/client/output
STATIC_CONTENT_ENDPOINT=http://localhost:8080/greeting/foo # cant use just /greeting, because this prints to stdout to measure startup time and it would result in very big docker logs sizes
DYNAMIC_CONTENT_ENDPOINT=http://localhost:8080/fruits
BLOCKING_RUN_RATES=(10000 20000 30000 40000 42000 44000 46000 48000 50000 60000 80000 100000)
REACTIVE_RUN_RATES=(10000 20000 30000 40000 45000 47000 48000 50000 60000 80000 100000 120000 122000 124000 126000)
STARTUP_ITERATIONS=5
DOCKER_CPUS=4
#DOCKER_MEM=256m
DOCKER_MEM=512m
docker build -f Dockerfile.db -t base-postgres .
# stop possibly still existing containers
docker stop base-db
sleep 5s
# run the database containers in detached mode and remove them as soon as you stop them (--rm)
# https://docs.docker.com/network/host/ | no port mapping needed, because it is run in the local network -> much better performance
# as there is no network address translation (NAT) needed, which really is a factor for a ~100k req/s and increasing
docker run --rm -d --network host --name base-db base-postgres
sleep 10s

echo "build applications and docker images"
cd blocking-api || exit
# skip tests: because the application needs to be run inside a clean docker container (for proper resource allocation)
# its database connection string has to point to the database container inside the network
# because of this when you build the application on the host system it will not be able to connect to the database (the connection string would need to be localhost) during the tests
./mvnw clean package -DskipTests
docker build -f src/main/docker/Dockerfile.jvm -t blocking_api-quarkus .

cd ../reactive-api || exit
./mvnw clean package -DskipTests # skip tests: see above
docker build -f src/main/docker/Dockerfile.jvm -t reactive_api-quarkus .

cd ../
echo "recreate output directories in /tmp/quarkus-test"
# remove client and server output directories (including their contents) and recreate them
if [ -d "${SERVER_OUTPUT_PATH}" ]; then rm -rf "${SERVER_OUTPUT_PATH}"; fi
mkdir -p ${SERVER_OUTPUT_PATH}
if [ -d "${CLIENT_OUTPUT_PATH}" ]; then rm -rf "${CLIENT_OUTPUT_PATH}"; fi
mkdir -p ${CLIENT_OUTPUT_PATH}

echo "" >${SERVER_OUTPUT_PATH}/reactive-StartUp.out
echo "" >${SERVER_OUTPUT_PATH}/blocking-StartUp.out

echo "measure startup times for both applications ${STARTUP_ITERATIONS} times"
for i in $(seq 1 ${STARTUP_ITERATIONS}); do
  # redirect all output (including messages & output generated by Quarkus and System.out.println)
  sh ./measureStartup.sh blocking-api/target/quarkus-app/quarkus-run.jar | grep -E 'EXECUTE|STARTUP|CALL HELLO' >>${SERVER_OUTPUT_PATH}/blocking-StartUp.out
  sh ./measureStartup.sh reactive-api/target/quarkus-app/quarkus-run.jar | grep -E 'EXECUTE|STARTUP|CALL HELLO' >>${SERVER_OUTPUT_PATH}/reactive-StartUp.out
done

APPLICATIONS=("blocking_api" "reactive_api")
# For each API start the docker container and for each Run Rate of the API do a warmup and then the load test
for APP_NAME in "${APPLICATIONS[@]}"; do
  # depending on what application is put under load assign the correct run rate https://stackoverflow.com/questions/19417015/how-to-copy-an-array-in-bash
  if [ "${APP_NAME}" = "blocking_api" ]; then
    RUN_RATES=("${BLOCKING_RUN_RATES[@]}")
  elif [ "${APP_NAME}" = "reactive_api" ]; then
    RUN_RATES=("${REACTIVE_RUN_RATES[@]}")
  fi
  docker stop "${APP_NAME}"
  sleep 5s
  # https://docs.docker.com/network/host/ | no port mapping needed
  docker run --rm -d --network host --name "${APP_NAME}" --cpus ${DOCKER_CPUS} --memory ${DOCKER_MEM} "${APP_NAME}"-quarkus
  sleep 5s
  curl -s -o ${SERVER_OUTPUT_PATH}/"${APP_NAME}".env.out -w "%{http_code}\n" http://localhost:8080/environment
  # Get the Process Id of the running .jar file (by the executed command, see -f parameter)-
  # store them in a file and afterwards save it in a variable (you can't assign it to a variable directly)
  pgrep -f quarkus-run.jar >${SERVER_OUTPUT_PATH}/javaApp.pid
  JAVA_APP_PID=$(cat ${SERVER_OUTPUT_PATH}/javaApp.pid)
  rm ${SERVER_OUTPUT_PATH}/javaApp.pid

  for RUN_RATE in "${RUN_RATES[@]}"; do
    # get the resource consumption (as a background process) of the process every second and as soon as it is terminates (see below) the content is written to a log file
    # also only retrieve the information in which the word java is located (so dont include the header row)
    echo "warmup for static content endpoint of ${APP_NAME} with ${RUN_RATE} req/s"
    # top -b -d 1 -p "${JAVA_APP_PID}" | grep java >"${SERVER_OUTPUT_PATH}"/"${APP_NAME}"-static-content-"${RUN_RATE}"-WarmUp-top.out &
    # TOP_PID=$!
    # warmup for static content endpoint
    wrk -t 4 -c 100 -d60s -R "${RUN_RATE}" ${STATIC_CONTENT_ENDPOINT} >"${CLIENT_OUTPUT_PATH}"/"${APP_NAME}"-static-content-"${RUN_RATE}"-WarmUp.wrk2.out
    # kill -9 "${TOP_PID}" # end with sig_kill
    sleep 5s

    echo "measurement (load test) of static content endpoint of ${APP_NAME} with ${RUN_RATE} req/s"
    top -b -d 1 -p "${JAVA_APP_PID}" | grep java >"${SERVER_OUTPUT_PATH}"/"${APP_NAME}"-static-content-"${RUN_RATE}"-Measure-top.out &
    TOP_PID=$!
    # measurement of static content endpoint
    wrk -t 4 -c 100 -d60s -R "${RUN_RATE}" --latency ${STATIC_CONTENT_ENDPOINT} >"${CLIENT_OUTPUT_PATH}"/"${APP_NAME}"-static-content-"${RUN_RATE}"-Measure.wrk2.out
    kill -9 "${TOP_PID}" # end with sig_kill
    sleep 5s
    # echo "warmup for dynamic content endpoint of ${APP_NAME} with ${RUN_RATE} req/s"
    # top -b -d 1 -p "${JAVA_APP_PID}" | grep java >"${SERVER_OUTPUT_PATH}"/"${APP_NAME}"-dynamic-content-"${RUN_RATE}"-WarmUp-top.out &
    # TOP_PID=$!
    # warmup for dynamic content endpoint (database interaction)
    # wrk -t 4 -c 100 -d60s -R "${RUN_RATE}" ${DYNAMIC_CONTENT_ENDPOINT} >"${CLIENT_OUTPUT_PATH}"/"${APP_NAME}"-dynamic-content-"${RUN_RATE}"-WarmUp.wrk2.out
    # kill -9 "${TOP_PID}" # end with sig_kill
    # sleep 5s

    # echo "measurement (load test) of dynamic content endpoint of ${APP_NAME} with ${RUN_RATE} req/s"
    # top -b -d 1 -p "${JAVA_APP_PID}" | grep java >"${SERVER_OUTPUT_PATH}"/"${APP_NAME}"-dynamic-content-"${RUN_RATE}"-Measure-top.out &
    # TOP_PID=$!
    # measurement of dynamic content endpoint
    # wrk -t 4 -c 100 -d60s -R "${RUN_RATE}" --latency ${DYNAMIC_CONTENT_ENDPOINT} >"${CLIENT_OUTPUT_PATH}"/"${APP_NAME}"-dynamic-content-"${RUN_RATE}"-Measure.wrk2.out
    # kill -9 "${TOP_PID}" # end with sig_kill
    # sleep 5s
  done

  docker logs "${APP_NAME}" >"${SERVER_OUTPUT_PATH}"/"${APP_NAME}".docker-run.log
  docker stop "${APP_NAME}"
  sleep 5s
done
docker stop base-db
